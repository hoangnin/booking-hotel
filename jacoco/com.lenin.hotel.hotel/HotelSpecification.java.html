<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HotelSpecification.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">hotel</a> &gt; <a href="index.source.html" class="el_package">com.lenin.hotel.hotel</a> &gt; <span class="el_source">HotelSpecification.java</span></div><h1>HotelSpecification.java</h1><pre class="source lang-java linenums">package com.lenin.hotel.hotel;

import com.lenin.hotel.hotel.model.Booking;
import com.lenin.hotel.hotel.model.Location;
import com.lenin.hotel.hotel.model.Hotel;
import com.lenin.hotel.hotel.model.PriceTracking;
import jakarta.persistence.criteria.*;
import org.springframework.data.jpa.domain.Specification;

import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

<span class="nc" id="L15">public class HotelSpecification {</span>

    public static Specification&lt;Hotel&gt; filterHotels(
            String name, Integer locationId, Double rating,
            Set&lt;Integer&gt; amenityIds, Double minPrice, Double maxPrice,
            Integer minRoomsAvailable, String hotelType, ZonedDateTime checkIn,
            ZonedDateTime checkOut) {

<span class="nc" id="L23">        return (Root&lt;Hotel&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) -&gt; {</span>
<span class="nc" id="L24">            List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L26" title="All 4 branches missed.">            if (name != null &amp;&amp; !name.isEmpty()) {</span>
<span class="nc" id="L27">                String likePattern = &quot;%&quot; + name.toLowerCase() + &quot;%&quot;;</span>

                // hotel.name
<span class="nc" id="L30">                Predicate namePredicate = cb.like(cb.lower(root.get(&quot;name&quot;)), likePattern);</span>

                // hotel.address
<span class="nc" id="L33">                Predicate addressPredicate = cb.like(cb.lower(root.get(&quot;address&quot;)), likePattern);</span>

                // location.name (cần join location trước)
<span class="nc" id="L36">                Join&lt;Hotel, Location&gt; locationJoin = root.join(&quot;location&quot;, JoinType.INNER);</span>
<span class="nc" id="L37">                Predicate locationNamePredicate = cb.like(cb.lower(locationJoin.get(&quot;name&quot;)), likePattern);</span>

<span class="nc" id="L39">                predicates.add(cb.or(namePredicate, addressPredicate, locationNamePredicate));</span>
            }

            // Join bảng Location
<span class="nc" id="L43">            Join&lt;Hotel, Location&gt; locationJoin = root.join(&quot;location&quot;, JoinType.INNER);</span>

            // Lọc theo locationId
<span class="nc bnc" id="L46" title="All 2 branches missed.">            if (locationId != null) {</span>
<span class="nc" id="L47">                predicates.add(cb.equal(locationJoin.get(&quot;id&quot;), locationId));</span>
            }


<span class="nc bnc" id="L51" title="All 2 branches missed.">            if (rating != null) {</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">                if (rating == 5) {</span>
<span class="nc" id="L53">                    predicates.add(cb.equal(root.get(&quot;rating&quot;), 5));</span>
                } else {
<span class="nc" id="L55">                    predicates.add(cb.between(root.get(&quot;rating&quot;), rating, rating + 1));</span>
                }
            }


<span class="nc bnc" id="L60" title="All 4 branches missed.">            if (amenityIds != null &amp;&amp; !amenityIds.isEmpty()) {</span>
                // Subquery để đếm số lượng tiện ích của khách sạn có trong danh sách amenityIds
<span class="nc" id="L62">                Subquery&lt;Long&gt; subquery = query.subquery(Long.class);</span>
<span class="nc" id="L63">                Root&lt;Hotel&gt; subRoot = subquery.from(Hotel.class);</span>
<span class="nc" id="L64">                Join&lt;Object, Object&gt; subAmenityJoin = subRoot.join(&quot;amenities&quot;, JoinType.INNER);</span>

<span class="nc" id="L66">                subquery.select(cb.count(subAmenityJoin.get(&quot;id&quot;)))</span>
<span class="nc" id="L67">                        .where(cb.equal(subRoot.get(&quot;id&quot;), root.get(&quot;id&quot;)),</span>
<span class="nc" id="L68">                                subAmenityJoin.get(&quot;id&quot;).in(amenityIds));</span>

                // Điều kiện: Số lượng amenities phải bằng đúng số lượng trong amenityIds
<span class="nc" id="L71">                predicates.add(cb.equal(subquery, (long) amenityIds.size()));</span>
            }

            // Tạo JOIN giữa Hotel và PriceTracking
<span class="nc" id="L75">            Join&lt;Hotel, PriceTracking&gt; priceTrackingJoin = root.join(&quot;priceTrackings&quot;, JoinType.INNER);</span>

            // Lọc theo khoảng giá từ bảng PriceTracking
<span class="nc bnc" id="L78" title="All 2 branches missed.">            if (minPrice != null) {</span>
<span class="nc" id="L79">                predicates.add(cb.greaterThanOrEqualTo(priceTrackingJoin.get(&quot;price&quot;), minPrice));</span>
            }
<span class="nc bnc" id="L81" title="All 2 branches missed.">            if (maxPrice != null) {</span>
<span class="nc" id="L82">                predicates.add(cb.lessThanOrEqualTo(priceTrackingJoin.get(&quot;price&quot;), maxPrice));</span>
            }


            // Lọc theo số lượng phòng trống
<span class="nc bnc" id="L87" title="All 2 branches missed.">            if (minRoomsAvailable != null) {</span>
<span class="nc" id="L88">                predicates.add(cb.greaterThanOrEqualTo(root.get(&quot;roomsAvailable&quot;), minRoomsAvailable));</span>
            }

            // Lọc theo loại khách sạn (hotelType)
<span class="nc bnc" id="L92" title="All 4 branches missed.">            if (hotelType != null &amp;&amp; !hotelType.isEmpty()) {</span>
<span class="nc" id="L93">                predicates.add(cb.equal(cb.lower(root.get(&quot;hotelType&quot;)), hotelType.toLowerCase()));</span>
            }

            // Tạo Subquery để kiểm tra khách sạn có bị đặt hết không
<span class="nc" id="L97">            Subquery&lt;Integer&gt; subquery = query.subquery(Integer.class);</span>
<span class="nc" id="L98">            Root&lt;Booking&gt; subRoot = subquery.from(Booking.class);</span>
<span class="nc" id="L99">            subquery.select(cb.literal(1)); // Chỉ cần check xem có booking nào trùng hay không</span>
<span class="nc" id="L100">            subquery.where(</span>
<span class="nc" id="L101">                    cb.equal(subRoot.get(&quot;hotel&quot;).get(&quot;id&quot;), root.get(&quot;id&quot;)), // Booking thuộc khách sạn đó</span>
<span class="nc" id="L102">                    cb.or(</span>
                            // TH1: checkIn yêu cầu nằm giữa một booking đã có (phòng đã có khách ở)
<span class="nc" id="L104">                            cb.and(</span>
<span class="nc" id="L105">                                    cb.lessThanOrEqualTo(subRoot.get(&quot;checkIn&quot;), checkIn),</span>
<span class="nc" id="L106">                                    cb.greaterThan(subRoot.get(&quot;checkOut&quot;), checkIn)</span>
                            ),
                            // TH2: checkOut yêu cầu nằm giữa một booking đã có (phòng đã có khách ở)
<span class="nc" id="L109">                            cb.and(</span>
<span class="nc" id="L110">                                    cb.lessThan(subRoot.get(&quot;checkIn&quot;), checkOut),</span>
<span class="nc" id="L111">                                    cb.greaterThanOrEqualTo(subRoot.get(&quot;checkOut&quot;), checkOut)</span>
                            ),
                            // TH3: Khoảng thời gian yêu cầu bao trùm khoảng thời gian đã đặt trước đó
<span class="nc" id="L114">                            cb.and(</span>
<span class="nc" id="L115">                                    cb.greaterThanOrEqualTo(subRoot.get(&quot;checkIn&quot;), checkIn),</span>
<span class="nc" id="L116">                                    cb.lessThanOrEqualTo(subRoot.get(&quot;checkOut&quot;), checkOut)</span>
                            )
                    )
            );

        // Loại bỏ các khách sạn đã bị đặt kín trong khoảng thời gian yêu cầu
<span class="nc" id="L122">            predicates.add(cb.not(cb.exists(subquery)));</span>



<span class="nc" id="L126">            return cb.and(predicates.toArray(new Predicate[0]));</span>
        };
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>